<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Itinerary Planner - Audio Interface</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #0a0a0a;
            color: #ffffff;
            height: 100vh;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
            gap: 2px;
        }

        /* Left Panel - AUDIO */
        .audio-panel {
            flex: 1;
            background-color: #1a1a1a;
            border-right: 1px solid #333;
            display: flex;
            flex-direction: column;
        }

        .panel-header {
            background-color: #2a2a2a;
            padding: 15px;
            font-size: 18px;
            font-weight: bold;
            border-bottom: 1px solid #333;
        }

        .audio-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .audio-visualizer {
            width: 100%;
            max-width: 400px;
            height: 120px;
            background-color: #1a1a1a;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 30px;
            position: relative;
            overflow: hidden;
            border: 2px solid #333;
        }

        .waveform-container {
            width: 100%;
            height: 100%;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .waveform-canvas {
            width: 100%;
            height: 100%;
            border-radius: 10px;
        }

        .waveform-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(26, 26, 26, 0.8);
            border-radius: 10px;
            transition: opacity 0.3s ease;
        }

        .waveform-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .waveform-status {
            font-size: 14px;
            color: #888;
            text-align: center;
        }

        .waveform-status.recording {
            color: #ff4444;
            animation: pulse 1s infinite;
        }

        .waveform-status.tts {
            color: #00ffff;
            animation: pulse 1.5s infinite;
        }

        /* Enhanced waveform animations */
        .waveform-container {
            position: relative;
        }

        .waveform-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent 30%, rgba(0, 255, 255, 0.1) 50%, transparent 70%);
            background-size: 200% 200%;
            animation: shimmer 3s ease-in-out infinite;
            border-radius: 10px;
            pointer-events: none;
        }

        @keyframes shimmer {
            0% { background-position: -200% -200%; }
            50% { background-position: 200% 200%; }
            100% { background-position: -200% -200%; }
        }

        .waveform-container.recording::before {
            background: linear-gradient(45deg, transparent 30%, rgba(255, 68, 68, 0.2) 50%, transparent 70%);
            animation: shimmer 1s ease-in-out infinite;
        }

        .waveform-container.tts::before {
            background: linear-gradient(45deg, transparent 30%, rgba(0, 255, 255, 0.2) 50%, transparent 70%);
            animation: shimmer 2s ease-in-out infinite;
        }

        .audio-bars-fallback {
            display: none;
            gap: 8px;
            margin-bottom: 30px;
        }

        .audio-bar {
            width: 20px;
            height: 60px;
            background-color: #2a4a4a;
            border-radius: 10px;
            transition: all 0.3s ease;
        }

        .audio-bar.active {
            background-color: #00ffff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }

        .audio-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .upload-area {
            border: 2px dashed #444;
            border-radius: 10px;
            padding: 30px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            max-width: 300px;
        }

        .upload-area:hover {
            border-color: #00ffff;
            background-color: #1a2a2a;
        }

        .upload-area.dragover {
            border-color: #00ffff;
            background-color: #1a2a2a;
        }

        .file-input {
            display: none;
        }

        /* Center Panel - CHAT */
        .chat-panel {
            flex: 2;
            background-color: #1a1a1a;
            border-right: 1px solid #333;
            display: flex;
            flex-direction: column;
        }

        .chat-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .chat-message {
            margin-bottom: 20px;
            padding: 15px;
            border-radius: 10px;
            max-width: 80%;
        }

        .chat-message.agent {
            background-color: #1a2a2a;
            border-left: 4px solid #00ffff;
            align-self: flex-start;
        }

        .chat-message.user {
            background-color: #2a1a2a;
            border-left: 4px solid #ff00ff;
            align-self: flex-end;
        }

        .message-sender {
            font-weight: bold;
            margin-bottom: 5px;
            color: #00ffff;
        }

        .message-text {
            line-height: 1.4;
            color: #ffffff;
        }

        .chat-input-area {
            padding: 20px;
            border-top: 1px solid #333;
            display: flex;
            gap: 10px;
        }

        .chat-input {
            flex: 1;
            padding: 12px;
            border: 1px solid #444;
            border-radius: 8px;
            background-color: #2a2a2a;
            color: #ffffff;
            font-size: 14px;
        }

        .chat-input:focus {
            outline: none;
            border-color: #00ffff;
        }

        .send-btn {
            padding: 12px 24px;
            background-color: #444;
            color: #ffffff;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .send-btn:hover {
            background-color: #00ffff;
            color: #000000;
        }

        /* Right Panel - Controls */
        .control-panel {
            flex: 1;
            background-color: #1a1a1a;
            display: flex;
            flex-direction: column;
            gap: 20px;
            padding: 20px;
        }

        .control-section {
            background-color: #2a2a2a;
            border-radius: 10px;
            padding: 15px;
        }

        .control-section h3 {
            margin-bottom: 15px;
            color: #00ffff;
            font-size: 16px;
        }



        .status-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding: 8px 0;
            border-bottom: 1px solid #444;
        }

        .status-value {
            color: #00ffff;
            font-weight: bold;
        }

        .mic-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        .mic-icon {
            font-size: 24px;
            color: #888;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .mic-icon.active {
            color: #00ffff;
        }

        .mic-icon.muted::after {
            content: '';
            position: absolute;
            width: 2px;
            height: 30px;
            background-color: #ff0000;
            transform: rotate(45deg);
            margin-left: -1px;
            margin-top: -15px;
        }

        .mic-select {
            flex: 1;
            padding: 8px;
            background-color: #1a1a1a;
            border: 1px solid #444;
            border-radius: 5px;
            color: #ffffff;
        }

        .mic-visualizer {
            display: flex;
            gap: 3px;
            justify-content: center;
        }

        .mic-dot {
            width: 6px;
            height: 6px;
            background-color: #666;
            border-radius: 50%;
            transition: all 0.2s ease;
        }

        .mic-dot.active {
            background-color: #00ffff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        .color-palette {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .color-swatch {
            width: 25px;
            height: 25px;
            border-radius: 5px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }

        .color-swatch:hover {
            transform: scale(1.1);
        }

        .color-swatch.selected {
            border-color: #ffffff;
            transform: scale(1.1);
        }

        .color-swatch.cyan { background-color: #00ffff; }
        .color-swatch.grey1 { background-color: #444444; }
        .color-swatch.grey2 { background-color: #666666; }
        .color-swatch.brown { background-color: #8B4513; }
        .color-swatch.green { background-color: #228B22; }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        ::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #00ffff;
        }

        /* Audio recording indicator */
        .recording-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: #ff0000;
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            display: none;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        /* Responsive design */
        @media (max-width: 1200px) {
            .container {
                flex-direction: column;
            }
            
            .audio-panel, .chat-panel, .control-panel {
                flex: none;
                height: auto;
            }
        }
    </style>
</head>
<body>
    <div class="recording-indicator" id="recordingIndicator">
        ðŸŽ¤ Recording...
    </div>

    <div class="container">
        <!-- Left Panel - AUDIO -->
        <div class="audio-panel">
            <div class="panel-header">AUDIO</div>
            <div class="audio-content">
                <div class="audio-visualizer" id="audioVisualizer">
                    <div class="waveform-container">
                        <canvas class="waveform-canvas" id="waveformCanvas"></canvas>
                        <div class="waveform-overlay hidden" id="waveformOverlay">
                            <div class="waveform-status" id="waveformStatus">Ready</div>
                        </div>
                    </div>
                </div>
                
                <div class="audio-bars-fallback" id="audioBarsFallback">
                    <div class="audio-bar"></div>
                    <div class="audio-bar"></div>
                    <div class="audio-bar"></div>
                    <div class="audio-bar"></div>
                    <div class="audio-bar"></div>
                </div>
                
                <div class="audio-controls">
                    <div class="upload-area" id="uploadArea">
                        <div>ðŸŽµ Drop audio file here</div>
                        <div style="font-size: 12px; margin-top: 10px; color: #888;">
                            or click to browse
                        </div>
                        <input type="file" id="audioFileInput" class="file-input" accept="audio/*">
                    </div>
                    
                    <button id="recordBtn" style="padding: 15px 30px; background-color: #00ffff; color: #000; border: none; border-radius: 25px; cursor: pointer; font-weight: bold;">
                        ðŸŽ¤ Start Recording
                    </button>
                </div>
            </div>
        </div>

        <!-- Center Panel - CHAT -->
        <div class="chat-panel">
            <div class="panel-header">CHAT</div>
            <div class="chat-content" id="chatContent">
                <div class="chat-message agent">
                    <div class="message-sender">Itine</div>
                    <div class="message-text">Hello! I'm Itine, your itinerary planner. Tell me about your trip!</div>
                </div>
            </div>
            
            <div class="chat-input-area">
                <input type="text" class="chat-input" id="chatInput" placeholder="Type a message">
                <button class="send-btn" id="sendBtn">SEND</button>
            </div>
        </div>

        <!-- Right Panel - Controls -->
        <div class="control-panel">
            <div class="control-section">
                <h3>STATUS</h3>
                <div class="status-item">
                    <span>Room connected:</span>
                    <span class="status-value" id="roomStatus">CONNECTED</span>
                </div>
                <div class="status-item">
                    <span>Agent connected:</span>
                    <span class="status-value" id="agentStatus">TRUE</span>
                </div>
            </div>

            <div class="control-section">
                <h3>MICROPHONE</h3>
                <div class="mic-controls">
                    <div class="mic-icon" id="micIcon">ðŸŽ¤</div>
                    <select class="mic-select" id="micSelect">
                        <option>Default - Microphone</option>
                    </select>
                </div>
                <div class="mic-visualizer" id="micVisualizer">
                    <div class="mic-dot"></div>
                    <div class="mic-dot"></div>
                    <div class="mic-dot"></div>
                    <div class="mic-dot"></div>
                    <div class="mic-dot"></div>
                </div>
            </div>

            <div class="control-section">
                <h3>COLOR</h3>
                <div class="color-palette">
                    <div class="color-swatch cyan selected" data-color="#00ffff"></div>
                    <div class="color-swatch grey1" data-color="#444444"></div>
                    <div class="color-swatch grey2" data-color="#666666"></div>
                    <div class="color-swatch brown" data-color="#8B4513"></div>
                    <div class="color-swatch green" data-color="#228B22"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class AudioInterface {
            constructor() {
                this.mediaRecorder = null;
                this.audioChunks = [];
                this.isRecording = false;
                this.recognition = null;
                this.synthesis = window.speechSynthesis;
                this.currentText = '';
                
                // Final input variable to store user input from any source
                this.finalUserInput = '';
                
                // Trip credentials object to store required information
                this.tripCredentials = {
                    origin: '',
                    destination: '',
                    startDate: '',
                    endDate: '',
                    numberOfDays: '',
                    isComplete: false
                };
                
                // Audio analysis properties
                this.audioContext = null;
                this.analyser = null;
                this.microphone = null;
                this.scriptProcessor = null;
                this.dataArray = null;
                this.animationId = null;
                
                // Waveform properties
                this.waveformCanvas = null;
                this.waveformCtx = null;
                this.waveformData = [];
                this.isTTSActive = false;
                this.currentAccentColor = '#00ffff';
                
                // TTS simulation properties
                this.ttsData = null;
                this.ttsInterval = null;
                
                // Loading sequence properties
                this.loadingInterval = null;
                
                this.initializeSpeechRecognition();
                this.initializeEventListeners();
                this.initializeWaveformVisualizer();
            }

            // Method to validate trip credentials
            validateTripCredentials() {
                const hasOrigin = this.tripCredentials.origin.trim() !== '';
                const hasDestination = this.tripCredentials.destination.trim() !== '';
                const hasStartDate = this.tripCredentials.startDate.trim() !== '';
                const hasEndDate = this.tripCredentials.endDate.trim() !== '';
                const hasNumberOfDays = this.tripCredentials.numberOfDays.trim() !== '';
                
                // Must have origin, destination, start date, and either end date OR number of days
                const isValid = hasOrigin && hasDestination && hasStartDate && (hasEndDate || hasNumberOfDays);
                
                this.tripCredentials.isComplete = isValid;
                return isValid;
            }

            // Method to get missing credentials
            getMissingCredentials() {
                const missing = [];
                if (!this.tripCredentials.origin.trim()) missing.push('origin');
                if (!this.tripCredentials.destination.trim()) missing.push('destination');
                if (!this.tripCredentials.startDate.trim()) missing.push('start date');
                if (!this.tripCredentials.endDate.trim() && !this.tripCredentials.numberOfDays.trim()) {
                    missing.push('end date or number of days');
                }
                return missing;
            }

            // Method to generate AI prompt from trip credentials
            generateAIPrompt() {
                if (!this.validateTripCredentials()) {
                    return null;
                }

                let prompt = `Arrange my trip from ${this.tripCredentials.origin} to ${this.tripCredentials.destination} from ${this.tripCredentials.startDate}`;
                
                if (this.tripCredentials.endDate) {
                    prompt += ` to ${this.tripCredentials.endDate}`;
                } else if (this.tripCredentials.numberOfDays) {
                    prompt += ` for ${this.tripCredentials.numberOfDays} days`;
                }
                
                return prompt;
            }

            // Method to ask for missing credentials
            askForMissingCredentials() {
                const missing = this.getMissingCredentials();
                if (missing.length === 0) return;

                let message = "I need some more information to create your itinerary. Please provide: ";
                message += missing.join(', ') + '.';
                
                this.addChatMessage('agent', message);
                this.speakText(message);
            }

            // Method to extract trip information from user input
            extractTripInfo(inputText) {
                const text = inputText.toLowerCase();
                let extracted = false;

                // Extract origin
                const originPatterns = [
                    /from\s+([^,\n]+?)(?:\s+to|\s+on|\s+starting|\s+beginning|$)/i,
                    /origin[:\s]+([^,\n]+?)(?:\s+to|\s+on|\s+starting|\s+beginning|$)/i,
                    /starting\s+from\s+([^,\n]+?)(?:\s+to|\s+on|\s+starting|\s+beginning|$)/i
                ];
                
                for (let pattern of originPatterns) {
                    const match = text.match(pattern);
                    if (match && !this.tripCredentials.origin) {
                        this.tripCredentials.origin = match[1].trim();
                        extracted = true;
                        break;
                    }
                }

                // Extract destination
                const destPatterns = [
                    /to\s+([^,\n]+?)(?:\s+on|\s+from|\s+starting|\s+beginning|$)/i,
                    /destination[:\s]+([^,\n]+?)(?:\s+on|\s+from|\s+starting|\s+beginning|$)/i,
                    /going\s+to\s+([^,\n]+?)(?:\s+on|\s+from|\s+starting|\s+beginning|$)/i
                ];
                
                for (let pattern of destPatterns) {
                    const match = text.match(pattern);
                    if (match && !this.tripCredentials.destination) {
                        this.tripCredentials.destination = match[1].trim();
                        extracted = true;
                        break;
                    }
                }

                // Extract dates - handle various formats including ordinal dates
                const datePatterns = [
                    /(\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4})/g,
                    /(\d{1,2}(?:st|nd|rd|th)?\s+(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)[a-z]*\s+\d{2,4})/gi,
                    /(\d{1,2}(?:st|nd|rd|th)?\s+(?:january|february|march|april|may|june|july|august|september|october|november|december)\s+\d{2,4})/gi,
                    /(january|february|march|april|may|june|july|august|september|october|november|december)\s+\d{1,2}(?:st|nd|rd|th)?,?\s+\d{2,4}/gi,
                    /(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)[a-z]*\s+\d{1,2}(?:st|nd|rd|th)?,?\s+\d{2,4}/gi,
                    // Handle dates without year (assume current year)
                    /(\d{1,2}(?:st|nd|rd|th)?\s+(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)[a-z]*)/gi,
                    /(\d{1,2}(?:st|nd|rd|th)?\s+(?:january|february|march|april|may|june|july|august|september|october|november|december))/gi,
                    /(january|february|march|april|may|june|july|august|september|october|november|december)\s+\d{1,2}(?:st|nd|rd|th)?/gi,
                    /(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)[a-z]*\s+\d{1,2}(?:st|nd|rd|th)?/gi,
                    // Handle "on" prefix
                    /on\s+(\d{1,2}(?:st|nd|rd|th)?\s+(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)[a-z]*)/gi,
                    /on\s+(\d{1,2}(?:st|nd|rd|th)?\s+(?:january|february|march|april|may|june|july|august|september|october|november|december))/gi,
                    /on\s+(january|february|march|april|may|june|july|august|september|october|november|december)\s+\d{1,2}(?:st|nd|rd|th)?/gi,
                    /on\s+(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)[a-z]*\s+\d{1,2}(?:st|nd|rd|th)?/gi
                ];
                
                for (let pattern of datePatterns) {
                    const matches = text.match(pattern);
                    if (matches) {
                        if (!this.tripCredentials.startDate) {
                            let dateStr = matches[0];
                            // If no year is specified, add current year
                            if (!dateStr.match(/\d{4}/)) {
                                const currentYear = new Date().getFullYear();
                                dateStr += ` ${currentYear}`;
                            }
                            this.tripCredentials.startDate = dateStr;
                            extracted = true;
                        } else if (!this.tripCredentials.endDate && matches.length > 1) {
                            let dateStr = matches[1];
                            // If no year is specified, add current year
                            if (!dateStr.match(/\d{4}/)) {
                                const currentYear = new Date().getFullYear();
                                dateStr += ` ${currentYear}`;
                            }
                            this.tripCredentials.endDate = dateStr;
                            extracted = true;
                        }
                    }
                }

                // Extract number of days
                const daysPatterns = [
                    /(\d+)\s+days?/i,
                    /for\s+(\d+)\s+days?/i,
                    /duration[:\s]+(\d+)\s+days?/i
                ];
                
                for (let pattern of daysPatterns) {
                    const match = text.match(pattern);
                    if (match && !this.tripCredentials.numberOfDays) {
                        this.tripCredentials.numberOfDays = match[1];
                        extracted = true;
                        break;
                    }
                }

                return extracted;
            }

            // Method to show loading sequence
            showLoadingSequence() {
                const loadingMessages = [
                    "ðŸ” Finding the best flights...",
                    "ðŸ¨ Searching for perfect accommodations...",
                    "ðŸŽ¯ Planning daily activities and attractions...",
                    "ðŸ½ï¸ Curating local dining recommendations...",
                    "ðŸ’° Calculating budget estimates...",
                    "ðŸ“‹ Compiling travel tips and information...",
                    "âœ¨ Finalizing your personalized itinerary..."
                ];

                let currentIndex = 0;
                const loadingInterval = setInterval(() => {
                    if (currentIndex < loadingMessages.length) {
                        // Update the last agent message with loading text
                        this.updateLastAgentMessage(loadingMessages[currentIndex]);
                        currentIndex++;
                    } else {
                        clearInterval(loadingInterval);
                    }
                }, 2000); // Change message every 2 seconds

                // Store interval ID to clear it later
                this.loadingInterval = loadingInterval;
            }

            // Method to update the last agent message
            updateLastAgentMessage(newText) {
                const chatContent = document.getElementById('chatContent');
                const agentMessages = chatContent.querySelectorAll('.chat-message.agent');
                
                if (agentMessages.length > 0) {
                    const lastMessage = agentMessages[agentMessages.length - 1];
                    const messageText = lastMessage.querySelector('.message-text');
                    if (messageText) {
                        messageText.textContent = newText;
                    }
                }
            }

            // Method to clear loading sequence
            clearLoadingSequence() {
                if (this.loadingInterval) {
                    clearInterval(this.loadingInterval);
                    this.loadingInterval = null;
                }
            }

            // Method to check if server is running
            async checkServerStatus() {
                try {
                    const response = await fetch('/', { method: 'HEAD' });
                    return response.ok;
                } catch (error) {
                    console.error('Server check failed:', error);
                    return false;
                }
            }

            // Method to send data to backend
            async sendToBackend(prompt) {
                try {
                    // Check if server is running first
                    const serverRunning = await this.checkServerStatus();
                    if (!serverRunning) {
                        throw new Error('Server is not running. Please start the server and try again.');
                    }

                    // Show initial loading message
                    this.addChatMessage('agent', 'ðŸš€ Starting to plan your trip...');
                    this.speakText('Starting to plan your trip');
                    
                    // Start loading sequence
                    this.showLoadingSequence();

                    console.log('Sending request to backend:', prompt);
                    console.log('Request URL:', '/api/generate-plan');

                    const response = await fetch('http://localhost:8081/api/generate-plan', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            text: prompt
                        })
                    });

                    console.log('Response status:', response.status);
                    console.log('Response ok:', response.ok);

                    if (!response.ok) {
                        const errorText = await response.text();
                        console.error('Response error text:', errorText);
                        throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);
                    }

                    const result = await response.json();
                    console.log('Backend response:', result);
                    
                    // Clear loading sequence
                    this.clearLoadingSequence();
                    
                    // Display the result in chat
                    if (result.data) {
                        this.addChatMessage('agent', result.data);
                        this.speakText(result.data);
                    } else {
                        this.addChatMessage('agent', 'I received a response but it seems to be empty. Please try again.');
                        this.speakText('I received a response but it seems to be empty. Please try again.');
                    }
                    
                    return result;
                } catch (error) {
                    console.error('Error sending to backend:', error);
                    console.error('Error type:', error.constructor.name);
                    console.error('Error message:', error.message);
                    
                    // Clear loading sequence on error
                    this.clearLoadingSequence();
                    
                    let errorMessage = 'Sorry, there was an error processing your request. ';
                    
                    if (error.name === 'TypeError' && error.message.includes('Failed to fetch')) {
                        errorMessage += 'Please make sure the server is running and try again.';
                    } else if (error.message.includes('HTTP error')) {
                        errorMessage += `Server returned an error: ${error.message}`;
                    } else {
                        errorMessage += 'Please try again.';
                    }
                    
                    this.addChatMessage('agent', errorMessage);
                    this.speakText(errorMessage);
                }
            }

            // Method to handle final user input from any source
            handleFinalUserInput(inputText) {
                // Extract trip information from the input
                this.extractTripInfo(inputText);
                
                // Check if we have all required credentials
                if (this.validateTripCredentials()) {
                    // Generate AI prompt
                    const aiPrompt = this.generateAIPrompt();
                    this.finalUserInput = aiPrompt;
                    console.log('Final AI Prompt:', this.finalUserInput);
                    console.log('Trip Credentials:', this.tripCredentials);
                    
                    // Send to backend
                    this.sendToBackend(this.finalUserInput);
                } else {
                    // Store the raw input and ask for missing information
                    this.finalUserInput = inputText;
                    console.log('User Input (incomplete):', this.finalUserInput);
                    console.log('Missing credentials:', this.getMissingCredentials());
                    this.askForMissingCredentials();
                }
            }

            initializeSpeechRecognition() {
                if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                    this.recognition = new SpeechRecognition();
                    this.recognition.continuous = false;
                    this.recognition.interimResults = false;
                    this.recognition.lang = 'en-US';

                    this.recognition.onresult = (event) => {
                        const transcript = event.results[0][0].transcript;
                        this.currentText = transcript;
                        this.addChatMessage('user', transcript);
                        this.speakText(transcript);
                        // Store in final input variable
                        this.handleFinalUserInput(transcript);
                    };

                    this.recognition.onerror = (event) => {
                        console.error('Speech recognition error:', event.error);
                    };
                } else {
                    console.warn('Speech recognition not supported');
                }
            }

            initializeEventListeners() {
                // Record button
                const recordBtn = document.getElementById('recordBtn');
                recordBtn.addEventListener('click', () => this.toggleRecording());

                // File upload
                const uploadArea = document.getElementById('uploadArea');
                const fileInput = document.getElementById('audioFileInput');

                uploadArea.addEventListener('click', () => fileInput.click());
                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadArea.classList.add('dragover');
                });
                uploadArea.addEventListener('dragleave', () => {
                    uploadArea.classList.remove('dragover');
                });
                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadArea.classList.remove('dragover');
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        this.handleAudioFile(files[0]);
                    }
                });

                fileInput.addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        this.handleAudioFile(e.target.files[0]);
                    }
                });

                // Chat input
                const sendBtn = document.getElementById('sendBtn');
                const chatInput = document.getElementById('chatInput');

                sendBtn.addEventListener('click', () => this.sendChatMessage());
                chatInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.sendChatMessage();
                    }
                });

                // Microphone icon
                const micIcon = document.getElementById('micIcon');
                micIcon.addEventListener('click', () => this.toggleMicrophone());

                // Color palette
                const colorSwatches = document.querySelectorAll('.color-swatch');
                colorSwatches.forEach(swatch => {
                    swatch.addEventListener('click', (event) => this.changeAccentColor(swatch.dataset.color, event));
                });
            }

            initializeWaveformVisualizer() {
                this.waveformCanvas = document.getElementById('waveformCanvas');
                this.waveformCtx = this.waveformCanvas.getContext('2d');
                this.visualizerBars = document.querySelectorAll('.audio-bar');
                this.micDots = document.querySelectorAll('.mic-dot');
                
                // Set canvas dimensions
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
                
                // Initialize Web Audio API
                this.initializeWebAudio();
                
                // Start animation loop
                this.animateWaveform();
            }

            resizeCanvas() {
                // Set canvas dimensions to match its display size
                const rect = this.waveformCanvas.getBoundingClientRect();
                this.waveformCanvas.width = rect.width * window.devicePixelRatio;
                this.waveformCanvas.height = rect.height * window.devicePixelRatio;
                
                // Scale the context to match device pixel ratio
                this.waveformCtx.scale(window.devicePixelRatio, window.devicePixelRatio);
                
                // Set CSS size back to original
                this.waveformCanvas.style.width = rect.width + 'px';
                this.waveformCanvas.style.height = rect.height + 'px';

                this.visualizerBars.forEach((bar, index) => {
                    if (Math.random() > 0.7) {
                        bar.classList.add('active');
                        // Apply current accent color to active bars
                        const currentColor = document.querySelector('.color-swatch.selected')?.dataset.color || '#00ffff';
                        bar.style.backgroundColor = currentColor;
                        bar.style.boxShadow = `0 0 20px ${currentColor}80`;
                        setTimeout(() => {
                            bar.classList.remove('active');
                            bar.style.backgroundColor = '';
                            bar.style.boxShadow = '';
                        }, 200);
                    }
                });

                this.micDots.forEach((dot, index) => {
                    if (Math.random() > 0.8) {
                        dot.classList.add('active');
                        // Apply current accent color to active dots
                        const currentColor = document.querySelector('.color-swatch.selected')?.dataset.color || '#00ffff';
                        dot.style.backgroundColor = currentColor;
                        dot.style.boxShadow = `0 0 10px ${currentColor}80`;
                        setTimeout(() => {
                            dot.classList.remove('active');
                            dot.style.backgroundColor = '';
                            dot.style.boxShadow = '';
                        }, 150);
                    }
                });
            }

            initializeWebAudio() {
                try {
                    // Create audio context
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.audioContext = new AudioContext();
                    
                    // Create analyser node with optimized settings for real-time visualization
                    this.analyser = this.audioContext.createAnalyser();
                    this.analyser.fftSize = 512; // Higher resolution for better waveform
                    this.analyser.smoothingTimeConstant = 0.3; // Less smoothing for more responsive visualization
                    this.analyser.minDecibels = -90;
                    this.analyser.maxDecibels = -10;
                    
                    // Create data array for frequency data
                    this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);
                    
                    console.log('Web Audio API initialized successfully');
                } catch (error) {
                    console.warn('Web Audio API not supported, using fallback visualization');
                    this.useFallbackVisualization();
                }
            }

            useFallbackVisualization() {
                document.getElementById('audioVisualizer').style.display = 'none';
                document.getElementById('audioBarsFallback').style.display = 'flex';
                
                // Simulate audio activity for fallback
                setInterval(() => {
                    if (this.isRecording || this.isTTSActive) {
                        this.updateFallbackVisualizer();
                    }
                }, 100);
            }

            updateFallbackVisualizer() {
                this.visualizerBars.forEach((bar, index) => {
                    if (Math.random() > 0.7) {
                        bar.classList.add('active');
                        const currentColor = document.querySelector('.color-swatch.selected')?.dataset.color || '#00ffff';
                        bar.style.backgroundColor = currentColor;
                        bar.style.boxShadow = `0 0 20px ${currentColor}80`;
                        setTimeout(() => {
                            bar.classList.remove('active');
                            bar.style.backgroundColor = '';
                            bar.style.boxShadow = '';
                        }, 200);
                    }
                });

                this.micDots.forEach((dot, index) => {
                    if (Math.random() > 0.8) {
                        dot.classList.add('active');
                        const currentColor = document.querySelector('.color-swatch.selected')?.dataset.color || '#00ffff';
                        dot.style.backgroundColor = currentColor;
                        dot.style.boxShadow = `0 0 10px ${currentColor}80`;
                        setTimeout(() => {
                            dot.classList.remove('active');
                            dot.style.backgroundColor = '';
                            dot.style.boxShadow = '';
                        }, 150);
                    }
                });
            }

            animateWaveform() {
                // Always continue the animation loop, even if audio context is suspended
                this.drawWaveform();
                this.animationId = requestAnimationFrame(() => this.animateWaveform());
            }

            drawWaveform() {
                if (!this.waveformCtx) return;

                const canvas = this.waveformCanvas;
                const ctx = this.waveformCtx;
                const rect = canvas.getBoundingClientRect();
                const width = rect.width;
                const height = rect.height;

                // Clear canvas
                ctx.clearRect(0, 0, width, height);

                const currentColor = this.currentAccentColor || document.querySelector('.color-swatch.selected')?.dataset.color || '#00ffff';

                if (this.analyser && (this.isRecording || this.isTTSActive) && this.audioContext && this.audioContext.state === 'running') {
                    // Real-time audio visualization - get fresh frequency data
                    this.analyser.getByteFrequencyData(this.dataArray);
                    this.drawAudioBars(ctx, width, height, currentColor);
                } else {
                    // Idle state - show subtle animated bars
                    this.drawIdleBars(ctx, width, height, currentColor);
                }

                // Draw center line
                ctx.strokeStyle = currentColor + '60'; // Semi-transparent
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.moveTo(10, height / 2);
                ctx.lineTo(width - 10, height / 2);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            drawAudioBars(ctx, width, height, currentColor) {
                let dataArray = this.dataArray;
                let barCount = Math.min(64, dataArray.length); // Limit bars for better visualization
                
                // Use TTS data if available
                if (this.isTTSActive && this.ttsData) {
                    dataArray = this.ttsData;
                    barCount = Math.min(64, dataArray.length);
                }
                
                const barWidth = (width - 20) / barCount; // Add padding
                const startX = 10; // Left padding
                
                ctx.shadowColor = currentColor;
                ctx.shadowBlur = 8;

                for (let i = 0; i < barCount; i++) {
                    // Get frequency data and normalize it
                    const normalizedValue = dataArray[i] / 255;
                    const barHeight = Math.max(4, normalizedValue * height * 0.9); // Minimum height of 4px
                    const x = startX + i * barWidth;
                    const y = (height - barHeight) / 2;

                    // Create gradient for each bar with intensity-based opacity
                    const gradient = ctx.createLinearGradient(x, y, x, y + barHeight);
                    const intensity = Math.min(1, normalizedValue + 0.3); // Ensure minimum visibility
                    const topColor = currentColor + Math.floor(intensity * 255).toString(16).padStart(2, '0');
                    const bottomColor = this.adjustColor(currentColor, -0.4) + Math.floor(intensity * 0.7 * 255).toString(16).padStart(2, '0');
                    
                    gradient.addColorStop(0, topColor);
                    gradient.addColorStop(1, bottomColor);

                    ctx.fillStyle = gradient;
                    
                    // Draw rounded rectangle with smoother edges
                    this.drawRoundedRect(ctx, x + 1, y, Math.max(2, barWidth - 2), barHeight, Math.min(3, barWidth / 2));
                    
                    // Add extra glow for high-intensity bars
                    if (normalizedValue > 0.7) {
                        ctx.shadowBlur = 15;
                        ctx.fillStyle = currentColor + '40'; // Semi-transparent overlay
                        this.drawRoundedRect(ctx, x + 1, y, Math.max(2, barWidth - 2), barHeight, Math.min(3, barWidth / 2));
                        ctx.shadowBlur = 8;
                    }
                }

                ctx.shadowBlur = 0;
            }

            drawIdleBars(ctx, width, height, currentColor) {
                const barCount = 32;
                const barWidth = width / barCount;
                const time = Date.now() * 0.001;
                
                ctx.shadowColor = currentColor;
                ctx.shadowBlur = 5;

                for (let i = 0; i < barCount; i++) {
                    // Create subtle wave pattern
                    const wave = Math.sin(time * 2 + i * 0.3) * 0.5 + 0.5;
                    const barHeight = wave * height * 0.3;
                    const x = i * barWidth;
                    const y = (height - barHeight) / 2;

                    // Create subtle gradient
                    const gradient = ctx.createLinearGradient(x, y, x, y + barHeight);
                    const alpha = 0.3 + wave * 0.4;
                    gradient.addColorStop(0, `${currentColor}${Math.floor(alpha * 255).toString(16).padStart(2, '0')}`);
                    gradient.addColorStop(1, `${currentColor}00`);

                    ctx.fillStyle = gradient;
                    
                    // Draw rounded rectangle
                    this.drawRoundedRect(ctx, x + 2, y, barWidth - 4, barHeight, 3);
                }

                ctx.shadowBlur = 0;
            }

            drawRoundedRect(ctx, x, y, width, height, radius) {
                ctx.beginPath();
                ctx.moveTo(x + radius, y);
                ctx.lineTo(x + width - radius, y);
                ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                ctx.lineTo(x + width, y + height - radius);
                ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                ctx.lineTo(x + radius, y + height);
                ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                ctx.lineTo(x, y + radius);
                ctx.quadraticCurveTo(x, y, x + radius, y);
                ctx.closePath();
                ctx.fill();
            }

            showWaveformStatus(type, message) {
                const overlay = document.getElementById('waveformOverlay');
                const status = document.getElementById('waveformStatus');
                const container = document.querySelector('.waveform-container');
                
                if (overlay && status) {
                    status.textContent = message;
                    status.className = `waveform-status ${type}`;
                    overlay.classList.remove('hidden');
                }
                
                if (container) {
                    container.classList.remove('recording', 'tts');
                    container.classList.add(type);
                }
            }

            hideWaveformStatus() {
                const overlay = document.getElementById('waveformOverlay');
                const container = document.querySelector('.waveform-container');
                
                if (overlay) {
                    overlay.classList.add('hidden');
                }
                
                if (container) {
                    container.classList.remove('recording', 'tts');
                }
            }

            async toggleRecording() {
                if (this.isRecording) {
                    this.stopRecording();
                } else {
                    await this.startRecording();
                }
            }

            async startRecording() {
                try {
                    // Resume audio context if it's suspended (required by some browsers)
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        await this.audioContext.resume();
                    }
                    
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    this.mediaRecorder = new MediaRecorder(stream);
                    this.audioChunks = [];
                    this.currentText = ''; // Reset current text for new recording

                    this.mediaRecorder.ondataavailable = (event) => {
                        this.audioChunks.push(event.data);
                    };

                    this.mediaRecorder.onstop = () => {
                        this.processAudioRecording();
                    };

                    this.mediaRecorder.start();
                    this.isRecording = true;
                    
                    // Connect microphone to audio analyzer for real-time visualization
                    if (this.audioContext && this.analyser) {
                        this.microphone = this.audioContext.createMediaStreamSource(stream);
                        this.microphone.connect(this.analyser);
                        
                        // Show recording status in waveform
                        this.showWaveformStatus('recording', 'Recording...');
                    }
                    
                    document.getElementById('recordBtn').textContent = 'â¹ï¸ Stop Recording';
                    document.getElementById('recordBtn').style.backgroundColor = '#ff4444';
                    document.getElementById('recordingIndicator').style.display = 'block';
                    
                    // Start speech recognition
                    if (this.recognition) {
                        this.recognition.start();
                    }
                } catch (error) {
                    console.error('Error starting recording:', error);
                    alert('Error accessing microphone. Please check permissions.');
                }
            }

            stopRecording() {
                if (this.mediaRecorder && this.isRecording) {
                    this.mediaRecorder.stop();
                    this.mediaRecorder.stream.getTracks().forEach(track => track.stop());
                    this.isRecording = false;
                    
                    // Disconnect microphone from analyzer
                    if (this.microphone) {
                        this.microphone.disconnect();
                        this.microphone = null;
                    }
                    
                    // Hide waveform status
                    this.hideWaveformStatus();
                    
                    document.getElementById('recordBtn').textContent = 'ðŸŽ¤ Start Recording';
                    document.getElementById('recordBtn').style.backgroundColor = '#00ffff';
                    document.getElementById('recordingIndicator').style.display = 'none';
                    
                    // Stop speech recognition
                    if (this.recognition) {
                        this.recognition.stop();
                    }
                }
            }

            processAudioRecording() {
                const audioBlob = new Blob(this.audioChunks, { type: 'audio/wav' });
                const audioUrl = URL.createObjectURL(audioBlob);
                
                // If speech recognition captured text, it was already processed in onresult
                // If not, we don't show any success message - just silently complete
                // The TTS will only happen if speech recognition successfully transcribed the audio
            }

            handleAudioFile(file) {
                if (!file.type.startsWith('audio/')) {
                    alert('Please select an audio file');
                    return;
                }

                // Simulate audio file processing
                const reader = new FileReader();
                reader.onload = (e) => {
                    // Simulate audio-to-text conversion
                    setTimeout(() => {
                        const simulatedText = `Processed audio file: ${file.name}`;
                        this.currentText = simulatedText;
                        this.addChatMessage('user', simulatedText);
                        this.speakText(simulatedText);
                        // Store in final input variable
                        this.handleFinalUserInput(simulatedText);
                    }, 2000);
                };
                reader.readAsArrayBuffer(file);
            }

            addChatMessage(sender, text) {
                const chatContent = document.getElementById('chatContent');
                const messageDiv = document.createElement('div');
                messageDiv.className = `chat-message ${sender}`;
                
                const senderDiv = document.createElement('div');
                senderDiv.className = 'message-sender';
                senderDiv.textContent = sender === 'user' ? 'You' : 'Itine';
                
                const textDiv = document.createElement('div');
                textDiv.className = 'message-text';
                textDiv.textContent = text;
                
                messageDiv.appendChild(senderDiv);
                messageDiv.appendChild(textDiv);
                chatContent.appendChild(messageDiv);
                
                // Auto-scroll to bottom
                chatContent.scrollTop = chatContent.scrollHeight;
            }

            sendChatMessage() {
                const chatInput = document.getElementById('chatInput');
                const text = chatInput.value.trim();
                
                if (text) {
                    this.addChatMessage('user', text);
                    this.speakText(text);
                    // Store in final input variable
                    this.handleFinalUserInput(text);
                    chatInput.value = '';
                    
                    // Simulate agent response based on missing credentials
                    setTimeout(() => {
                        const missing = this.getMissingCredentials();
                        let response;
                        
                        if (missing.length > 0) {
                            if (missing.includes('origin')) {
                                response = "Great! I'd love to help you plan your trip. Where are you traveling from?";
                            } else if (missing.includes('destination')) {
                                response = "Perfect! Where would you like to go?";
                            } else if (missing.includes('start date')) {
                                response = "Excellent choice! When would you like to start your trip?";
                            } else if (missing.includes('end date or number of days')) {
                                response = "Almost there! When does your trip end, or how many days will you be traveling?";
                            } else {
                                response = "I need a bit more information to create your perfect itinerary. Please provide: " + missing.join(', ') + ".";
                            }
                        } else {
                            response = "Perfect! I have all the information I need. Let me create your personalized itinerary!";
                        }
                        
                        this.addChatMessage('agent', response);
                        this.speakText(response);
                    }, 1000);
                }
            }

            speakText(text) {
                if (this.synthesis) {
                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.rate = 0.9;
                    utterance.pitch = 1;
                    
                    // Show TTS status in waveform
                    this.showWaveformStatus('tts', 'Speaking...');
                    this.isTTSActive = true;
                    
                    // Create simulated audio data for TTS visualization
                    this.createTTSSimulation();
                    
                    utterance.onend = () => {
                        this.isTTSActive = false;
                        this.hideWaveformStatus();
                        this.stopTTSSimulation();
                    };
                    
                    utterance.onerror = () => {
                        this.isTTSActive = false;
                        this.hideWaveformStatus();
                        this.stopTTSSimulation();
                    };
                    
                    this.synthesis.speak(utterance);
                }
            }

            createTTSSimulation() {
                // Create simulated frequency data for TTS visualization
                this.ttsData = new Uint8Array(128);
                this.ttsInterval = setInterval(() => {
                    // Generate wave-like pattern for TTS
                    if (this.ttsData && this.ttsData.length > 0) {
                        for (let i = 0; i < this.ttsData.length; i++) {
                            const time = Date.now() * 0.01;
                            const wave = Math.sin(time + i * 0.2) * 0.5 + 0.5;
                            this.ttsData[i] = Math.floor(wave * 150 + 50);
                        }
                    }
                }, 50);
            }

            stopTTSSimulation() {
                if (this.ttsInterval) {
                    clearInterval(this.ttsInterval);
                    this.ttsInterval = null;
                }
                this.ttsData = null;
            }

            toggleMicrophone() {
                const micIcon = document.getElementById('micIcon');
                if (micIcon.classList.contains('active')) {
                    micIcon.classList.remove('active');
                    micIcon.classList.add('muted');
                } else {
                    micIcon.classList.remove('muted');
                    micIcon.classList.add('active');
                }
            }

            changeAccentColor(color, event) {
                // Remove selected class from all swatches
                document.querySelectorAll('.color-swatch').forEach(swatch => {
                    swatch.classList.remove('selected');
                });
                
                // Add selected class to clicked swatch
                event.target.classList.add('selected');
                
                // Update CSS custom properties
                document.documentElement.style.setProperty('--accent-color', color);
                
                // Update all accent color elements consistently
                this.updateAccentColors(color);
            }

            updateAccentColors(color) {
                // Update audio bars
                document.querySelectorAll('.audio-bar.active').forEach(bar => {
                    bar.style.backgroundColor = color;
                    bar.style.boxShadow = `0 0 20px ${color}80`;
                });

                // Update status values
                document.querySelectorAll('.status-value').forEach(status => {
                    status.style.color = color;
                });

                // Update message senders
                document.querySelectorAll('.message-sender').forEach(sender => {
                    sender.style.color = color;
                });

                // Update microphone icon when active
                const micIcon = document.getElementById('micIcon');
                if (micIcon.classList.contains('active')) {
                    micIcon.style.color = color;
                }

                // Update mic dots when active
                document.querySelectorAll('.mic-dot.active').forEach(dot => {
                    dot.style.backgroundColor = color;
                    dot.style.boxShadow = `0 0 10px ${color}80`;
                });

                // Update send button hover state
                const sendBtn = document.getElementById('sendBtn');
                sendBtn.addEventListener('mouseenter', () => {
                    sendBtn.style.backgroundColor = color;
                    sendBtn.style.color = '#000000';
                });
                sendBtn.addEventListener('mouseleave', () => {
                    sendBtn.style.backgroundColor = '#444';
                    sendBtn.style.color = '#ffffff';
                });

                // Update record button
                const recordBtn = document.getElementById('recordBtn');
                if (!this.isRecording) {
                    recordBtn.style.backgroundColor = color;
                }

                // Update upload area hover state
                const uploadArea = document.getElementById('uploadArea');
                uploadArea.addEventListener('mouseenter', () => {
                    uploadArea.style.borderColor = color;
                    uploadArea.style.backgroundColor = this.adjustColor(color, -0.1);
                });
                uploadArea.addEventListener('mouseleave', () => {
                    uploadArea.style.borderColor = '#444';
                    uploadArea.style.backgroundColor = 'transparent';
                });

                // Update waveform colors (will be applied on next draw cycle)
                this.currentAccentColor = color;
            }

            adjustColor(color, factor) {
                // Helper function to adjust color brightness
                const hex = color.replace('#', '');
                const r = Math.max(0, Math.min(255, parseInt(hex.substr(0, 2), 16) + Math.round(255 * factor)));
                const g = Math.max(0, Math.min(255, parseInt(hex.substr(2, 2), 16) + Math.round(255 * factor)));
                const b = Math.max(0, Math.min(255, parseInt(hex.substr(4, 2), 16) + Math.round(255 * factor)));
                return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
            }


        }

        // Initialize the audio interface when page loads
        document.addEventListener('DOMContentLoaded', () => {
            const app = new AudioInterface();
            app.speakText("Hello! I'm Itine, your itinerary planner. I'll help you create the perfect travel itinerary. Please tell me: where are you traveling from, where are you going, and when?");
        });
    </script>
</body>
</html>
